/**
 * @file Тесты для middleware i18n роутинга
 */

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// Mock для next-intl/middleware
const mockCreateMiddleware = vi.fn(() => () => {});
vi.mock('next-intl/middleware', () => ({
  default: mockCreateMiddleware,
}));

// Mock для routing
vi.mock('../../i18n/routing.js', () => ({
  defaultLocale: 'en',
  locales: ['en', 'ru'],
}));

// Очистка mock'ов между тестами для предотвращения конфликтов
afterEach(() => {
  vi.resetAllMocks();
});

// Импорт middleware для тестирования
let middlewareModule: typeof import('../../middleware.js');

describe('middleware', () => {
  beforeEach(async () => {
    middlewareModule = await import('../../middleware.js');
  });

  describe('экспорт по умолчанию', () => {
    it('должен экспортировать middleware функцию', async () => {
      // Поскольку middleware зависит от next-intl, просто проверяем что экспорт существует
      expect(middlewareModule).toHaveProperty('default');
      expect(middlewareModule.default).toBeDefined();
    });
  });

  describe.skip('конфигурация middleware', () => {
    it('должен экспортировать config с правильным типом', async () => {
      const { config } = middlewareModule;

      expect(config).toBeDefined();
      expect(typeof config).toBe('object');
      expect(config).toHaveProperty('matcher');
    });

    it('должен иметь правильный matcher паттерн', async () => {
      const { config } = middlewareModule;

      expect(config.matcher).toEqual(['/((?!api|_next|.*\\..*).*)']);
    });

    it('matcher должен быть массивом с одним элементом', async () => {
      const { config } = middlewareModule;

      expect(Array.isArray(config.matcher)).toBe(true);
      expect(config.matcher).toHaveLength(1);
    });

    it('matcher паттерн должен исключать API routes', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        // Паттерн должен содержать negative lookahead для 'api'
        expect(new RegExp(pattern)).toEqual(expect.any(RegExp));
        expect(pattern).toMatch(/(?!api)/);
      }
    });

    it('matcher паттерн должен исключать _next', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        expect(new RegExp(pattern)).toEqual(expect.any(RegExp));
        expect(pattern).toMatch(/(?!_next)/);
      }
    });

    it('matcher паттерн должен исключать статические файлы', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        expect(new RegExp(pattern)).toEqual(expect.any(RegExp));
        expect(pattern).toMatch(/(?!.*\\..*)/);
      }
    });
  });

  describe.skip('интеграция с next-intl', () => {
    it('должен быть совместим с next-intl middleware API', async () => {
      const module = middlewareModule;

      // Middleware экспорт должен существовать
      expect(module.default).toBeDefined();
    });
  });

  describe('структура файла', () => {
    it('должен иметь два экспорта: default и config', async () => {
      const module = middlewareModule;

      expect(module).toHaveProperty('default');
      expect(module).toHaveProperty('config');
      expect(Object.keys(module)).toHaveLength(2);
    });

    it('default экспорт должен существовать', async () => {
      const { default: middleware } = middlewareModule;

      expect(middleware).toBeDefined();
    });

    it('config экспорт должен быть объектом', async () => {
      const { config } = middlewareModule;

      expect(typeof config).toBe('object');
      expect(config).not.toBeNull();
    });
  });

  describe('поведение middleware (интеграционное)', () => {
    it('должен быть готов к использованию в Next.js приложении', async () => {
      const { default: middleware } = middlewareModule;

      // Middleware должен существовать для использования Next.js
      expect(middleware).toBeDefined();
    });

    it('конфигурация должна соответствовать Next.js MiddlewareConfig', async () => {
      const { config } = middlewareModule;

      // Проверяем, что config имеет структуру, ожидаемую Next.js
      expect(config).toHaveProperty('matcher');
      expect(Array.isArray(config.matcher)).toBe(true);
      if (Array.isArray(config.matcher)) {
        expect(config.matcher.every((item: any) => typeof item === 'string')).toBe(true);
      }
    });
  });

  describe('исключения в matcher', () => {
    it('паттерн должен содержать исключения для API routes', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        expect(pattern).toMatch(/(?!api)/);
      }
    });

    it('паттерн должен содержать исключения для Next.js internals', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        expect(pattern).toMatch(/(?!_next)/);
      }
    });

    it('паттерн должен содержать исключения для статических файлов', async () => {
      const { config } = middlewareModule;
      const pattern = config.matcher?.[0];

      if (typeof pattern === 'string') {
        expect(pattern).toMatch(/(?!.*\\..*)/);
      }
    });
  });
});
