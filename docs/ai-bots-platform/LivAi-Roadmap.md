## LivAi Roadmap (без воды)

Документ фиксирует **порядок работ** так, чтобы:

- не пришлось рефакторить архитектуру позже;
- UI не “обгонял” API и контракты;
- интеграции/вебхуки были надёжными (dedupe/retry/DLQ);
- мульти-тенантность была встроена с самого начала.

### 0 Принципы (что не обсуждаем) ✅

- **Архитектура монорепо**: как в `LivAi-Structure.md` (services + ports/adapters + use_cases). ✅
- **Сервисы на Python**: папки `domain/ ports/ use_cases/ entrypoints/ adapters/ tests/`. ✅
- **Надёжность интеграций**: входящие вебхуки → очередь → обработка; идемпотентность; DLQ. ✅
- **Tenant isolation**: все данные и действия "привязаны" к workspace/tenant. ✅

---

## Фаза 0 — Среда разработки (локально) ✅

**Цель:** повторяемая локальная среда “одной командой”.

### Результаты ✅

- Python venv + зависимости (`requirements.txt`, `requirements-dev.txt`). ✅
- Docker Compose инфраструктура: Postgres/Redis/ClickHouse/MinIO/Qdrant. ✅
- Авто-init инфраструктуры (ClickHouse DB, MinIO buckets, Qdrant collection). ✅
- Проверка доступности: `scripts/infra_check.py`. ✅
- Единые python-конфиги: `config/python/*`. ✅

### Критерии готовности ✅

- `docker compose up -d` поднимает всё без ручных команд. ✅
- `python scripts/infra_check.py` → `All infra checks passed.`. ✅

---

## Фаза 1 — “Вертикальный срез” MVP API (U1 + U3/U5 + U10) ✅

**Цель:** иметь работающий backend-контур, к которому можно подключать UI без последующего переписывания. ✅

### 1.0 Минимальное усиление: `command_id` / `operation_id` (сразу) ✅

**Что:** во всех “операциях” (LLM-turn, обработка webhook, запуск джобы) заложить поле:

- `operation_id` — **строго уникальный идентификатор операции**. ✅

**Зачем:** ✅

- дедуп не только входящих webhook'ов, но и **LLM-turn'ов**; ✅
- безопасные ретраи "ответь ещё раз" без дублей; ✅
- унификация для очередей/саг/оркестрации. ✅

**Практика:** это 1 поле в таблицах/событиях сейчас → экономия недель позже. ✅

### 1.1 Сервисы (минимум) ✅

1. `services/api-gateway` (входная точка)
   - CORS, rate limiting (позже), health/ready. ✅
   - единый формат ошибок и trace-id. ✅
   - `X-Operation-Id` (operation_id) на вход/выход. ✅
   - каркас `/v1/*` роутинга (proxy/stub). ✅
2. `services/auth-service`
   - регистрация/логин; ✅
   - workspace/tenant при регистрации (U1); ✅
   - выпуск JWT (access/refresh) (MVP). ✅
3. `services/bots-service`
   - CRUD ботов (U3/U4); ✅
   - редактирование инструкции/настроек (U5); ✅
   - версии конфигурации бота (чтобы не ломать прод при правках). ✅
4. `services/conversations-service` (минимально)
   - “тест-чат” (U10): хранение треда/сообщений, запуск “turn” (stub/эхо). ✅

### 1.2 Данные (Postgres) ✅

Минимальные таблицы (первые миграции):

- tenants/workspaces ✅
- users ✅
- bots + bot_versions (instruction/settings) ✅
- conversations: threads/messages (для тест-чата) ✅
- audit_log (минимум: кто/что/когда менял конфигурацию) ✅
- llm_turns (для дедупликации LLM запросов) ✅
- webhook_events + job_queue + dead_letter_queue (для надежности интеграций) ✅

Минимальные поля для “устойчивости” в потоках обработки:

- `command_id`/`operation_id` (см. 1.0) — в местах, где есть retry/dedupe. ✅

### 1.3 Контракты API ✅

Нужно зафиксировать до начала UI: ✅

- `/v1/*` роутинг через gateway; ✅ (каркас)
- единая форма ошибки (`code`, `message`, `trace_id`, `details`); ✅ (каркас)
- DTO для auth/workspace/bots/conversations. ✅

### Критерии готовности ✅

- можно пройти U1→U3→U5→U10 через API (Postman/HTTPie). ✅
- миграции Alembic воспроизводимы. ✅
- tenant isolation соблюдается в запросах и данных. ✅

---

## Фаза 2 — UI (Web/PWA) “по каркасу” из LivAiBot-Specs

**Когда стартуем UI:** после завершения Фазы 1 (контракты API + основные CRUD).

### 2.1 Что делаем в UI в первую очередь

- Навигационный каркас (Dashboard/Bots/Knowledge/Channels/Dialogs/Billing/Team/Settings) — без полной реализации.
- Экран регистрации/входа + создание workspace (U1).
- Экран “Боты”: список + создание + редактор инструкции (U3/U5).
- Экран “Тест-чат” (U10).

### Критерии готовности

- UI работает только через `api-gateway` (никаких прямых вызовов к сервисам).
- Ошибки и валидации согласованы с backend DTO.

---

## Фаза 3 — Knowledge/RAG (U6) + файлы (MinIO) + векторное хранилище (Qdrant)

**Цель:** “база знаний” как ключевая ценность продукта.

### 3.0 Минимальное усиление: decision trace для RAG (сразу)

**Что:** фиксировать “почему ответ такой” в виде минимального `retrieval_log`:

- `bot_version_id`
- `query`
- `selected_chunks` (ids/refs + порядок)
- `score` (или `scores`)

**Зачем (не для UI):**

- анализ качества (“почему выбрались эти куски”);
- база для будущего reranking/fine-tuning;
- объяснимость для enterprise.

**Где хранить:**

- на старте — Postgres (простая таблица),
- позже — ClickHouse (аналитика), но схему продумать сразу.

### 3.1 Сервисы

- `services/knowledge-service`
  - загрузка файлов (в MinIO);
  - создание источника знаний;
  - индексирование (job);
  - “quality check” (примеры вопросов, найденные куски, что не найдено).
- `services/ai-service` (на этом этапе можно без реального LLM)
  - embeddings provider (позже — Yandex);
  - retrieval + цитирование источников.

### 3.2 Надёжность задач

Минимум:

- очередь задач (первично Redis, позже Celery/Message Queue);
- ретраи + DLQ + экран/ручка для повторного запуска job.

### Критерии готовности

- U6 работает end-to-end: файл → MinIO → индексация → поиск/цитаты.
- версии индекса/источников фиксируются (для отката качества).

---

## Фаза 4 — Интеграции и вебхуки (U7–U9) “правильно”

**Цель:** подключать каналы без потери сообщений и без “двойной обработки”.

### 4.1 Обязательные механики (до первого коннектора)

- webhook ingress в gateway;
- нормализация событий (единый формат);
- дедупликация по idempotency key (Redis);
- очередь обработки + DLQ;
- rate limit + backoff + circuit breaker на коннекторах.

### 4.2 Первый коннектор (выбрать один)

Рекомендуемый порядок (по росту полезности и проверке надёжности):

1. **Webhook API (generic)** — универсальный вход
2. Telegram (aiogram)
3. CRM (amo/Bitrix/RetailCRM)

### Критерии готовности

- повторная доставка webhook не создаёт дублей;
- сбои коннектора не валят весь сервис/тенант.

---

## Фаза 5 — Auth/Security + Team/Roles + API Keys (U14, A7)

**Цель:** безопасная мульти-тенант платформа.

### Минимум

- роли в workspace (owner/admin/editor/viewer);
- audit log на изменения конфигурации;
- API keys (для внешних интеграций и “персональный API канал”).

---

## Фаза 6 — Billing/Limits/Usage (U13, A3/A4)

**Цель:** монетизация без ручного администрирования.

### Минимум

- metering событий (usage events) — **сразу продумать типы**:
  - `llm_tokens`
  - `conversations_started`
  - `messages_processed`
  - `webhook_events`
  - `integration_calls`
- лимиты по тарифу (боты/диалоги/токены/интеграции);
- алерты/блокировки при превышении;
- отчётность по tenant.

---

## Фаза 7 — Observability (минимум, но сразу правильно)

**Цель:** диагностика и SLA.

### Минимум

- корреляционный `trace_id` везде;
- Sentry для ошибок;
- Prometheus метрики (request count/latency/queue depth/DLQ).

---

## Админ-панель и AdminJS — когда и как

### Когда делать админку

Админка как функциональность нужна **рано** (диагностика, DLQ, лимиты), но UI-оболочку можно позже.

### AdminJS — рекомендация

- **Не начинать с AdminJS**.
- Сначала сделать `admin-service` (FastAPI) с админскими ручками/политиками доступа.
- UI для админки подключать **после стабилизации модели и RBAC/tenant isolation**.

---

## Риски (чтобы не “поплыть”)

- **UI до контрактов API** → гарантированный рефакторинг.
- **Вебхуки без очереди/дедупа** → дубли/таймауты/потеря сообщений.
- **AdminJS напрямую к БД** без строгих политик → риск утечек и нарушений tenant isolation.
- **ClickHouse/MinIO/Qdrant без init job’ов** → ручные “шаманства” на каждом окружении.
